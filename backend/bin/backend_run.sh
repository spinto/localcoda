#/bin/bash
#Run for debug and test

#Basic functions
function error(){
  echo "ERROR: $2"
  exit $1
}
function check_sw(){
  for sw in $*; do
		which $sw &>/dev/null
    [[ $? -ne 0 ]] && error 2 "$sw not found in the PATH. This is required."
  done
}
function check_env(){
  for c in $*; do
    eval [[ -z "\$$c" ]] && error 3 "Configuration value of $c not set. Please set it in the $APPDIR/cfg/conf file!"
  done
}

#Check basic software is there
check_sw jq readlink grep

#Get app directory and load basic configuration
SWDIR="`readlink -f "$0"`"; SWDIR="${SWDIR%/*}"
APPDIR="`readlink -f "${SWDIR%/*}"`"; APPDIR="${APPDIR%/}"
WWWDIR=`readlink -f $APPDIR/www`
[[ -e "$APPDIR/cfg/conf" ]] || error 1 "Cannot find configuration file at $APPDIR/cfg/conf"
source $APPDIR/cfg/conf

#Load commandline options
APP_VERSION=0.0.1
function usage {
  cat <<:usage
localcoda backend run version $APP_VERSION
Usage:
  backend_run [options] <tutorial-dir> [<index-file>]

Where the arguments are:
  <tutorial-dir> is the main directory for your tutorials, relative to the TUTORIALS_VOLUME
	               volume containing the tutorials. For local orchestrator, you can use an
								 absolute path, pointing to the local disk instead than TUTORIALS_VOLUME.
  <index-file>   [optional] is the path of the index file relative to the <tutorial-dir>.
                 Defaults to "index.json". This is useful when you have several scenarios
  							 in the same tutorial directory.

Options:
  -h             displays this help page
  -o <key>=<val> override the configuration option (in the $APPDIR/cfg/conf file). See
                 the content of the $APPDIR/cfg/conf file for specific options to override
  -u <uuid>      use a custom UUID (instead of the one automatically generated by this script)
  -W             enable writing in the tutorials folder. This is only for administrators!
  -d | --nowait  do not wait for the backend to be ready before closing the app. The script
                 will release once the backend is started, and you can check its status via
                 the backend_ls command
:usage
  exit 1
}

TUTORIAL_DIR=
INDEX_FILE=
LOCAL_UUID=
WAIT_FOR_START=true
TUTORIALS_WRITE=false
[[ -z "$1" ]] && usage
while [[ "$#" -gt 0 ]]; do
  case "$1" in
   -o) eval "$2"; shift 2 ;;
   -u) LOCAL_UUID="$2"; shift 2 ;;
   -W) TUTORIALS_WRITE=true; shift 1;; 
   -d | --nowait) WAIT_FOR_START=false ;;
   -h | --help) usage ;;
   *) if [[ -z "$TUTORIAL_DIR" ]]; then
	      TUTORIAL_DIR="${1%/}"
				[[ -z "$TUTORIAL_DIR" ]] && TUTORIAL_DIR=" "
      elif [[ -z "$INDEX_FILE" ]]; then
			  INDEX_FILE="$1"
      else
        error 1 "Unrecognized argument $1. See help!"
      fi
      shift 1
    ;;
  esac
done
[[ "$TUTORIAL_DIR" == " " ]] && TUTORIAL_DIR=
#Check required configuration is set
check_env VIRT_ENGINE IMAGES_${VIRT_ENGINE^^}_MAPFILE EXT_MAINHOST EXT_PROXYHOST_SCHEME TUTORIAL_MAX_TIME ORCHESTRATION_ENGINE INT_BASEPATH_SCHEME EXECUTION_NAME_SCHEME REMOTE_PORT TUTORIALS_VOLUME 
if [[ $ORCHESTRATION_ENGINE == "local" ]]; then
  check_sw docker
	check_env LOCAL_IPPORT
elif [[ $ORCHESTRATION_ENGINE == "kubernetes" ]]; then
  check_sw kubectl
	check_env KUBERNETES_NAMESPACE KUBERNETES_BACKEND_WWW_CONFIGMAP KUBERNETES_LIMITS_MEMORY KUBERNETES_LIMITS_CPU 
else
	error 2 "Orchestration engine $ORCHESTRATION_ENGINE is invalid!"
fi
if [[ $VIRT_ENGINE == "docker" ]]; then
  IMAGES_MAPFILE=$IMAGES_DOCKER_MAPFILE
elif [[ $VIRT_ENGINE == "sysbox" ]]; then
  IMAGES_MAPFILE=$IMAGES_SYSBOX_MAPFILE
else
  error 2 "Virtualization engine $VIRT_ENGINE is invalid!"
fi
eval IMAGES_MAPFILE="\$IMAGES_${VIRT_ENGINE^^}_MAPFILE"
[[ "${IMAGES_MAPFILE:0:1}" != "/" ]] && IMAGES_MAPFILE="$APPDIR/$IMAGES_MAPFILE"
[[ -f "$IMAGES_MAPFILE" ]] || error 33 "Cannot find image mapfile $IMAGES_MAPFILE"

#Set defaults
[[ -z "$INDEX_FILE" ]] && INDEX_FILE="index.json"
[[ -z "$LOCAL_UUID" ]] && LOCAL_UUID="`uuidgen`"

#Calculate execution container name (using the UUID)
eval EXECUTION_NAME=$EXECUTION_NAME_SCHEME

#Load the backend run info we need from the tutorial. What we need is:
#  BACKEND_IMAGE: the image of the tutorial
#  BACKEND_T_DIR: the volume (if relative) or the directory (if absolute) containing the tutorials
#  BACKEND_T_MODE: the mode of the mount of the tutorial dir (can be 'ro' or 'rw')
#  BACKEND_T_SUBPATH: the sub-path of the tutorial volume to mount
if [[ "${TUTORIAL_DIR:0:1}" == "/" ]]; then
  #This is a local path, you can mount it only in the local orchestrator and no subpath is present
	[[ $ORCHESTRATION_ENGINE == "local" ]] || error 3 "You can use a local tutorial path only for the local orchestration engine"
	BACKEND_T_DIR="$TUTORIAL_DIR"
	BACKEND_T_SUBPATH=

  #Check if tutorial exists and extract image backend info
  [[ -f "$TUTORIAL_DIR/$INDEX_FILE" ]] || error 1 "Invalid tutorial folder or file path provided. No index.json!"
  BACKEND_INFO=( `jq -r '.backend.imageid + " " + .backend.mountmode' < $TUTORIAL_DIR/$INDEX_FILE` )

else
  #This is a path relative to the volume. We need still to resolve it to check the tutorial exists and to get the image id from it
	BACKEND_T_DIR="$TUTORIALS_VOLUME"
  BACKEND_T_SUBPATH="$TUTORIAL_DIR"

  #Check if tutorial exists and extract image backend info
	if [[ -n "$TUTORIALS_VOLUME_ACCESS_MOUNT" ]]; then
    #Tutorial volume is mounted locally. Access it from local dir.
		[[ -f "$TUTORIALS_VOLUME_ACCESS_MOUNT/$TUTORIAL_DIR/$INDEX_FILE" ]] || error 1 "Invalid tutorial folder or file path provided. No index.json!"
		BACKEND_INFO=( `jq -r '.backend.imageid + " " + .backend.mountmode' < $TUTORIALS_VOLUME_ACCESS_MOUNT/$TUTORIAL_DIR/$INDEX_FILE` )
	elif [[ -n "$TUTORIALS_VOLUME_ACCESS_IMAGE" ]]; then
    #Tutorial volume need to be accessed remotely. we spawn a container to do so
    if [[ $ORCHESTRATION_ENGINE == "local" ]]; then
			BACKEND_INFO=( `docker run --rm -v $TUTORIALS_VOLUME:/data/tutorials:ro  "$TUTORIALS_VOLUME_ACCESS_IMAGE" cat /data/tutorials/$TUTORIAL_DIR/$INDEX_FILE | jq -r '.backend.imageid + " " + .backend.mountmode'` )
			[[ ${PIPESTATUS[0]} -ne 0 || -z "$BACKEND_INFO" ]] && error 1 "Invalid tutorial folder or file path provided. No index.json!"
    elif [[ $ORCHESTRATION_ENGINE == "kubernetes" ]]; then
	    echo "Warning: using the kubernetes engine without a locally mounted tutorials volume is slow and not recommended. Set the TUTORIALS_VOLUME_ACCESS_MOUNT option to a local path mounting or mirroring your tutorials"
			echo "Starting tutorial access helper pod..."
      cat <<EOF | kubectl -n "$KUBERNETES_NAMESPACE" apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: $EXECUTION_NAME-helper
spec:
  containers:
  - name: helper
    image: $TUTORIALS_VOLUME_ACCESS_IMAGE
    command: ["/bin/sh", "-c", "read -u 2"]
    volumeMounts:
    - mountPath: /data/tutorials
      name: tutorials-path
  volumes:
  - name: tutorials-path
    persistentVolumeClaim:
      claimName: $TUTORIALS_VOLUME
EOF
      [[ $? -ne 0 ]] && error 3 "Failed to create helper pod!"
      kubectl -n "$KUBERNETES_NAMESPACE" wait --for=condition=Ready pod/$EXECUTION_NAME-helper --timeout=60s
      [[ $? -ne 0 ]] && error 3 "Helper pod did not start. Maybe something is wrong with your PVC!"
      #Access the file
      echo "Getting tutorial info..."
  		BACKEND_INFO=( `kubectl -n "$KUBERNETES_NAMESPACE" exec pod/$EXECUTION_NAME-helper -- /bin/cat /data/tutorials/$TUTORIAL_DIR/$INDEX_FILE | jq -r '.backend.imageid + " " + .backend.mountmode'` )
      res=${PIPESTATUS[0]}
			#Remove the pod
      echo "Cleaning up..."
      kubectl -n "$KUBERNETES_NAMESPACE" delete pod/$EXECUTION_NAME-helper
      #Check we have the info
			[[ $res -ne 0 || -z "$BACKEND_INFO" ]] && error 1 "Invalid tutorial folder or file path provided. No index.json!"
    else
		  error 12 "This mode is not supported with $ORCHESTRATION_ENGINE orchestration engine"
    fi
	else
		error 14 "You need to set one of TUTORIALS_VOLUME_ACCESS_MOUNT or TUTORIALS_VOLUME_ACCESS_IMAGE options to use tutorial volumes."
	fi
fi
BACKEND_IMAGE="${BACKEND_INFO[0]}"
if [[ "${BACKEND_INFO[1]}" == "rw" ]]; then
  $TUTORIALS_WRITE || error 33 "You need to run this tutorial as an administrator, with write mode enabled!"
	BACKEND_T_MODE=rw
else
	BACKEND_T_MODE=ro
fi

#Look if the image to run is into your mapfile
IMAGE_INFO="`grep "^$BACKEND_IMAGE " $IMAGES_MAPFILE`"
[[ -z "$IMAGE_INFO" ]] && error 33 "Tutorial image backend is $IMAGE_BACKEND, but $IMAGE_BACKEND is not in the $IMAGES_MAPFILE"
IMAGE_INFO=( $IMAGE_INFO )
IMAGE_TORUN="${IMAGE_INFO[1]}"
DOCKER_HOSTNAME="${IMAGE_INFO[2]}"
[[ -z "$IMAGE_TORUN" ]] && error 34 "Invalid $IMAGES_MAPFILE entry for $IMAGE_BACKEND. Image name not found!"
[[ -z "$DOCKER_HOSTNAME" ]] && error 34 "Invalid $IMAGES_MAPFILE entry for $IMAGE_BACKEND. Docker hostname not found!"

#Get the base path from scheme
eval INT_BASEPATH=$INT_BASEPATH_SCHEME

#Get exection name from scheme
PORT="PORT"
eval EXT_PROXYHOST=$EXT_PROXYHOST_SCHEME

#Use the orchestration engine to run the backend instance
if [[ $ORCHESTRATION_ENGINE == "local" ]]; then

  #Determine local tutorial path mount point
	if [[ "${BACKEND_T_DIR:0:1}" == "/" ]]; then
    #This is a local bind mount
		DOCKER_T_MOUNT="type=bind"
	else
    #This is a volume mount
		DOCKER_T_MOUNT="type=volume"
	fi
  #Add tutorial mount source and destination
	DOCKER_T_MOUNT="$DOCKER_T_MOUNT,src=$BACKEND_T_DIR,dst=/etc/localcoda/tutorial"
  #Add mode of mount
  [[ "$BACKEND_T_MODE" == "ro" ]] && DOCKER_T_MOUNT="$DOCKER_T_MOUNT,ro"
  #Add volume subpath (if specified)
	[[ -n "$BACKEND_T_SUBPATH" ]] && DOCKER_T_MOUNT="$DOCKER_T_MOUNT,volume-subpath=$BACKEND_T_SUBPATH"

  #Get runtime engine
  if [[ $VIRT_ENGINE == "docker" ]]; then
    DOCKER_RUN_EXTRA="--privileged --cgroupns=host"
  elif [[ $VIRT_ENGINE == "sysbox" ]]; then
    DOCKER_RUN_EXTRA="--runtime=sysbox-runc"
  else
    error 32 "Virtualization engine $VIRT_ENGINE not supported in local mode"
	fi

  #Start the container in the background
  echo "Starting containter $EXECUTION_NAME..."
  docker run $DOCKER_RUN_EXTRA --name "$EXECUTION_NAME" -l readyurl=http://$EXT_MAINHOST$INT_BASEPATH -l "instanceid=$LOCAL_UUID" -d --hostname "$DOCKER_HOSTNAME" --mount $DOCKER_T_MOUNT -v $WWWDIR:/etc/localcoda/www:ro -e LOCALCODA_OPTIONS="$INDEX_FILE,$INT_BASEPATH,$EXT_MAINHOST,$EXT_PROXYHOST,$TUTORIAL_MAX_TIME,$TUTORIAL_EXIT_ON_DISCONNECT" -p $LOCAL_IPPORT:$REMOTE_PORT --rm -it "$IMAGE_TORUN"
  [[ $? -ne 0 ]] && error 1 "Failed to start container"

  #Start sidecar to terminate container after given startup time.
  if [[ "$TUTORIAL_MAX_TIME" != "-1" ]]; then
    (sleep $TUTORIAL_MAX_TIME; docker stop "$EXECUTION_NAME" &>/dev/null) &
  fi

  #Wait for the backend to be ready
  if $WAIT_FOR_START; then
    echo "Waiting for $EXECUTION_NAME to start..."
    WAIT_TIMEOUT=60
    READY_STATE=1
    while [[ "$READY_STATE" -ne 0 && $WAIT_TIMEOUT -gt 0 ]]; do
      sleep 1
      docker exec "$EXECUTION_NAME" bash -c '[[ -e /etc/localcoda/ready ]]'
      READY_STATE=$?
      WAIT_TIMEOUT=$(( --WAIT_TIMEOUT ))
    done
    [[ $WAIT_TIMEOUT -eq 0 ]] && error 44 "Timeout while waiting for tutorial to start... use backend_ls command to get more info..."

    #Tutorial is started
    echo "Your tutorial is ready and accessible from:
    http://$EXT_MAINHOST$INT_BASEPATH "
  else
    echo "Your tutorial is starting. You can check its status with ./backend_ls.sh $LOCAL_UUID"
  fi
elif [[ $ORCHESTRATION_ENGINE == "kubernetes" ]]; then

  #Check we are not using a local dir, as this is not accessible from kubernetes
  [[ "${BACKEND_T_DIR:0:1}" == "/" ]] && error 55 "Kubernetes orchestator can support only volumes hosting local dirs"

  #Check runtime engine
  [[ $VIRT_ENGINE != "docker" && $VIRT_ENGINE == "sysbox" ]] && error 32 "Virtualization engine $VIRT_ENGINE not supported in kubernetes mode"

  echo "TODO: I need to apply time limits (maybe with a job and an ownerreference for a service)"
  {
    cat <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: $EXECUTION_NAME
  annotations:
    readyurl: "http://$EXT_MAINHOST$INT_BASEPATH"
EOF
  [[ $VIRT_ENGINE == "sysbox" ]] && echo "    io.kubernetes.cri-o.userns-mode: \"auto:size=65536\""
  cat <<EOF
  labels:
    localcoda-instanceid: "$LOCAL_UUID"
spec:
  hostname: $DOCKER_HOSTNAME
EOF
  [[ $VIRT_ENGINE == "sysbox" ]] && echo "  runtimeClassName: sysbox-runc"
  cat <<EOF
  containers:
  - name: app
    image: $IMAGE_TORUN
EOF
  [[ $VIRT_ENGINE == "docker" ]] && cat <<EOF
    securityContext:
      privileged: true
EOF
cat <<EOF
    env:
    - name: LOCALCODA_OPTIONS
      value: "$INDEX_FILE,$INT_BASEPATH,$EXT_MAINHOST,$EXT_PROXYHOST,$TUTORIAL_MAX_TIME,$TUTORIAL_EXIT_ON_DISCONNECT"
    ports:
    - containerPort: 1
    volumeMounts:
    - mountPath: /etc/localcoda/tutorial
      name: tutorials-path
EOF
  [[ "$BACKEND_T_MODE" == "ro" ]] && echo "      readOnly: true"
cat <<EOF
    - mountPath: /etc/localcoda/www
      name: www-path
      readOnly: true
    startupProbe:
      exec:
        command:
        - cat
        - /etc/localcoda/ready
      initialDelaySeconds: 1
      periodSeconds: 1
      failureThreshold: 60
    lifecycle:
      preStop:
        exec:
          command: ["/usr/sbin/poweroff"]
    resources:
      limits:
        memory: "$KUBERNETES_LIMITS_MEMORY"
        cpu: "$KUBERNETES_LIMITS_CPU"
  restartPolicy: Never
  volumes:
  - name: tutorials-path
    persistentVolumeClaim:
      claimName: $TUTORIALS_VOLUME
  - name: www-path
    configMap:
      name: $KUBERNETES_BACKEND_WWW_CONFIGMAP
---
apiVersion: v1
kind: Service
metadata:
  name: $EXECUTION_NAME
spec:
  selector:
    localcoda-instanceid: "$LOCAL_UUID"
  ports:
    - protocol: TCP
      port: 80
      targetPort: 1
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $EXECUTION_NAME-app
spec:
  ingressClassName: nginx
  rules:
  - host: "$EXT_MAINHOST"
    http:
      paths:
      - pathType: Prefix
        path: "$INT_BASEPATH"
        backend:
          service:
            name: $EXECUTION_NAME
            port:
              number: 80
---
EOF
  #Generate external proxyhost regex for nginx
  EXT_PROXYHOST_REGEX="~^${EXT_PROXYHOST/PORT/[0-9]+}$"
  EXT_PROXYHOST_REGEX="${EXT_PROXYHOST_REGEX//./\.}"
  EXT_PROXYHOST_80="${EXT_PROXYHOST//PORT/80}"
cat <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $EXECUTION_NAME-proxy
  annotations:
    nginx.ingress.kubernetes.io/server-alias: "$EXT_PROXYHOST_REGEX"
spec:
  ingressClassName: nginx
  rules:
  - host: "$EXT_PROXYHOST_80"
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: $EXECUTION_NAME
            port:
              number: 80
EOF
  } | kubectl -n "$KUBERNETES_NAMESPACE" apply -f -
  [[ $? -ne 0 ]] && error 54 "Failed to start backend pod"

  #Wait for pod to be ready (if requested)
  if $WAIT_FOR_START; then
    echo "Waiting for $EXECUTION_NAME to start..."
    kubectl -n "$KUBERNETES_NAMESPACE" wait --for=condition=Ready pod/$EXECUTION_NAME --timeout=60s

    #Tutorial is started
    echo "Your tutorial is ready and accessible from:
    http://$EXT_MAINHOST$INT_BASEPATH "
  else
    echo "Your tutorial is starting. You can check its status with ./backend_ls.sh $LOCAL_UUID"
  fi

fi
#all done correctly if we are at this point
exit 0
