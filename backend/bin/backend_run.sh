#/bin/bash
#Run for debug and test

#Basic functions
function error(){
  echo "ERROR: $2"
  exit $1
}
function check_sw(){
  for sw in $*; do
		which $sw &>/dev/null
    [[ $? -ne 0 ]] && error 2 "$sw not found in the PATH. This is required."
  done
}
function check_env(){
  for c in $*; do
    eval [[ -z "\$$c" ]] && error 3 "Configuration value of $c not set. Please set it in the $APPDIR/cfg/conf file!"
  done
}

#Check basic software is there
check_sw jq readlink grep

#Get app directory and load basic configuration
SWDIR="`readlink -f "$0"`"; SWDIR="${SWDIR%/*}"
APPDIR="`readlink -f "${SWDIR%/*}"`"; APPDIR="${APPDIR%/}"
WWWDIR=`readlink -f $APPDIR/www`
[[ -e "$APPDIR/cfg/conf" ]] || error 1 "Cannot find configuration file at $APPDIR/cfg/conf"
source $APPDIR/cfg/conf

#Load commandline options
APP_VERSION=0.0.1
function usage {
  cat <<:usage
localcoda backend run version $APP_VERSION
Usage:
  backend_run [options] <tutorial-dir> [<index-file>]

Where the arguments are:
  <tutorial-dir> is the main directory for your tutorials. This need to contain all files
                 required for the tutorial execution. If relative, it is resolved againist
  							 the TUTORIALS_MOUNT_POINT configuration path 
  <index-file>   [optional] is the path of the index file relative to the <tutorial-dir>.
                 Defaults to "index.json". This is useful when you have several scenarios
  							 in the same tutorial directory.

Options:
  -h             displays this help page
  -o <key>=<val> override the configuration option (in the $APPDIR/cfg/conf file). See
                 the content of the $APPDIR/cfg/conf file for specific options to override
  -u <uuid>      use a custom UUID (instead of the one automatically generated by this script)
  -d | --nowait  do not wait for the backend to be ready before closing the app. The script
                 will release once the backend is started, and you can check its status via
                 the backend_ls command
:usage
  exit 1
}

TUTORIAL_DIR=
INDEX_FILE=
LOCAL_UUID=
WAIT_FOR_START=true
[[ -z "$1" ]] && usage
while [[ "$#" -gt 0 ]]; do
  case "$1" in
   -o) eval "$2"; shift 2 ;;
	 -u) LOCAL_UUID="$2"; shift 2 ;;
   -d | --nowait) WAIT_FOR_START=false ;;
   -h | --help) usage ;;
   *) if [[ -z "$TUTORIAL_DIR" ]]; then
	      TUTORIAL_DIR="${1%/}"
			elif [[ -z "$INDEX_FILE" ]]; then
			  INDEX_FILE="$1"
      else
        error 1 "Unrecognized argument $1. See help!"
      fi
      shift 1
    ;;
  esac
done
#Check required configuration is set
check_env VIRT_ENGINE IMAGES_${VIRT_ENGINE^^}_MAPFILE EXT_MAINHOST EXT_PROXYHOST_SCHEME TUTORIAL_MAX_TIME ORCHESTRATION_ENGINE INT_BASEPATH_SCHEME EXECUTION_NAME_SCHEME REMOTE_PORT 
if [[ $ORCHESTRATION_ENGINE == "local" ]]; then
  check_sw docker
	check_env LOCAL_IPPORT
elif [[ $ORCHESTRATION_ENGINE == "kubernetes" ]]; then
  check_sw kubectl
else
	error 2 "Orchestration engine $ORCHESTRATION_ENGINE is invalid!"
fi
if [[ $VIRT_ENGINE == "docker" ]]; then
  IMAGES_MAPFILE=$IMAGES_DOCKER_MAPFILE
  DOCKER_RUN_EXTRA="--privileged --cgroupns=host"
elif [[ $VIRT_ENGINE == "sysbox" ]]; then
  IMAGES_MAPFILE=$IMAGES_SYSBOX_MAPFILE
  DOCKER_RUN_EXTRA="--runtime=sysbox-runc"
else
  error 2 "Virtualization engine $VIRT_ENGINE is invalid!"
fi
eval IMAGES_MAPFILE="\$IMAGES_${VIRT_ENGINE^^}_MAPFILE"
[[ "${IMAGES_MAPFILE:0:1}" != "/" ]] && IMAGES_MAPFILE="$APPDIR/$IMAGES_MAPFILE"
[[ -f "$IMAGES_MAPFILE" ]] || error 33 "Cannot find image mapfile $IMAGES_MAPFILE"

#Set defaults
[[ -z "$INDEX_FILE" ]] && INDEX_FILE="index.json"
[[ -z "$LOCAL_UUID" ]] && LOCAL_UUID="`uuidgen`"

#Load tutorial info, determine which image to run
[[ -e "$TUTORIAL_DIR/$INDEX_FILE" ]] || error 1 "Invalid tutorial folder or file path provded. No index.json!"
IMAGE_BACKEND="`jq -r .backend.imageid < $TUTORIAL_DIR/$INDEX_FILE`"

#Calculate dynamic paths
eval INT_BASEPATH=$INT_BASEPATH_SCHEME
eval EXECUTION_NAME=$EXECUTION_NAME_SCHEME
PORT="PORT"
eval EXT_PROXYHOST=$EXT_PROXYHOST_SCHEME

#Look if the image to run is into your mapfile
IMAGE_INFO="`grep "^$IMAGE_BACKEND " $IMAGES_MAPFILE`"
[[ -z "$IMAGE_INFO" ]] && error 33 "Tutorial image backend is $IMAGE_BACKEND, but $IMAGE_BACKEND is not in the $IMAGES_MAPFILE"
IMAGE_INFO=( $IMAGE_INFO )
IMAGE_TORUN="${IMAGE_INFO[1]}"
DOCKER_HOSTNAME="${IMAGE_INFO[2]}"
[[ -z "$IMAGE_TORUN" ]] && error 34 "Invalid $IMAGES_MAPFILE entry for $IMAGE_BACKEND. Image name not found!"
[[ -z "$DOCKER_HOSTNAME" ]] && error 34 "Invalid $IMAGES_MAPFILE entry for $IMAGE_BACKEND. Docker hostname not found!"

#Use the orchestration engine to run the backend instance
if [[ $ORCHESTRATION_ENGINE == "local" ]]; then

  #Start the container in the background
  echo "Starting containter $EXECUTION_NAME..."
  docker run $DOCKER_RUN_EXTRA --name "$EXECUTION_NAME" -d --hostname "$DOCKER_HOSTNAME" -v $TUTORIAL_DIR:/etc/localcoda/tutorial:ro -v $WWWDIR:/etc/localcoda/www:ro -e LOCALCODA_OPTIONS="$INDEX_FILE,$INT_BASEPATH,$EXT_MAINHOST,$EXT_PROXYHOST,$TUTORIAL_MAX_TIME,$TUTORIAL_EXIT_ON_DISCONNECT" -p $LOCAL_IPPORT:$REMOTE_PORT --rm -it "$IMAGE_TORUN"
  [[ $? -ne 0 ]] && error 1 "Failed to start container"

  #Start sidecar to terminate container after given startup time.
  if [[ "$TUTORIAL_MAX_TIME" != "-1" ]]; then
    (sleep $TUTORIAL_MAX_TIME; docker stop "$EXECUTION_NAME" &>/dev/null) &
  fi

  #Wait for the backend to be ready
  echo "Waiting for $EXECUTION_NAME to start..."
  WAIT_TIMEOUT=60
  READY_STATE=
  while [[ -z "$READY_STATE" && $WAIT_TIMEOUT -gt 0 ]]; do
    sleep 1
    READY_STATE="`docker exec "$EXECUTION_NAME" bash -c '[[ -e /etc/localcoda/ready ]] && cat /etc/localcoda/ready'`"
    WAIT_TIMEOUT=$(( --WAIT_TIMEOUT ))
  done
  [[ $WAIT_TIMEOUT -eq 0 ]] && error 44 "Timeout while waiting for tutorial to start... use backend_ls command to get more info..."

  #Tutorial is started
  echo "Your tutorial is accessible from:
  $READY_STATE "

elif $ORCHESTRATION_ENGINE == "kubernetes" ]]; then
  error 99 "not implemented"
fi
#all done correctly if we are at this point
exit 0
